/**
 * generated by Xtext
 */
package org.xtext.passi.generator;

import com.google.common.base.Objects;
import com.google.inject.Injector;
import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.commons.io.FilenameUtils;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.QualifiedName;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.ISelectionService;
import org.eclipse.ui.IWorkbench;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.text.passi.generationUi.DocGenLauncher;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xtext.passi.DocGenStandaloneSetup;
import org.xtext.passi.MetamodelKeyAttributes;
import org.xtext.passi.PassiPersistentModelExtensions;
import org.xtext.passi.docGen.Attribute;
import org.xtext.passi.docGen.Model;
import org.xtext.passi.docGen.TagName;
import org.xtext.passi.docGen.element;
import org.xtext.passi.docGen.emptyElement;
import org.xtext.passi.docGen.startTag;
import org.xtext.passi.generator.DocumentationBuilder;
import org.xtext.passi.metamodels.MetamodelsLoader;

/**
 * Main class for documentation generation. It includes the entry point
 * method called when doc generation is selected from the eclipse
 * workspace (toolbar, menu or contextual menu).
 * 
 * @author Davide Guastella (<i>davide.guastella90@gmail.com</i>)
 */
@SuppressWarnings("all")
public class DocGenGenerator implements IGenerator {
  private String selectedModelFullPath;
  
  private Model modelToCompile;
  
  /**
   * la uso perch√® memorizzo informazioni personalizzate su eclass feature e riga corrente,
   * visto che devo generare la doc. tabella per tabella...
   * 
   * This hash table contains the informations needed for building the
   * documentation, such the EClass name, the row and the value of
   * every element in the persistence model document.
   * 
   * Every entry is in the form of:
   * <pre>
   * {<i>Key:</i> [EClassName:AttributeName:CurrentRowInModel], <i>value:</i> AttributeValue}
   * </pre>
   * The value <i>AttributeValue</i> of the entry is the value of the attribute <i>AttributeName</i>.
   */
  private Hashtable<String,String> persistenceModelHashTable;
  
  /**
   * The name space of the model that must be converted
   */
  private String ModelNameSpace;
  
  /**
   * The absolute path to the metamodel referenced by the model that has to be converted
   */
  private String metamodelFileName;
  
  /**
   * The document representing the metamodel.
   */
  private static Document metamodelDoc;
  
  /**
   * The set of current model's elements.
   */
  private EList<element> modelElements;
  
  private DocGenLauncher launcherUI;
  
  /**
   * This is a list of strings containing the name of the EClasses that must not be included
   * in the final documentation.
   */
  private List<String> excludedEClasses;
  
  /**
   * This is a list of strings containing the name of the EStructuralFeatures that must not be included
   * in the final documentation. Every string is in the form of
   * 
   * <pre>
   * "[ECLASS],[ESTRUCTURALFEATURE]"
   * </pre>
   */
  private List<String> excludedFeatures;
  
  /**
   * The type of the generated documentation.
   */
  private String outputDocumentationType;
  
  /**
   * The list containing the EClass nodes from the metamodel used
   * to compile the selected persistence model file.
   */
  private NodeList EClassList;
  
  /**
   * Entry point. This function is called when user select "Generate Documentation" from the
   * contextual menu or the tool bar. It reads the metamodel informations, builds the
   * necessary data structure and opens the launcher window.
   */
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    try {
      Hashtable<String,String> _hashtable = new Hashtable<String, String>();
      this.persistenceModelHashTable = _hashtable;
      ArrayList<String> _arrayList = new ArrayList<String>();
      this.excludedFeatures = _arrayList;
      ArrayList<String> _arrayList_1 = new ArrayList<String>();
      this.excludedEClasses = _arrayList_1;
      this.outputDocumentationType = "";
      boolean _ReloadMetamodels = MetamodelsLoader.ReloadMetamodels();
      boolean _not = (!_ReloadMetamodels);
      if (_not) {
        Shell _shell = new Shell();
        MessageDialog.openError(_shell, "DocGen Error", "Can\'t load the metamodel for the selected file. Please ensure the path to the metamodels folder is set. (Right-click project->Properties->Metamodels");
        return;
      }
      boolean _isValidModelFile = this.isValidModelFile();
      boolean _not_1 = (!_isValidModelFile);
      if (_not_1) {
        Shell _shell_1 = new Shell();
        MessageDialog.openError(_shell_1, "DocGen Error", "The selected file is not a valid model file.");
        return;
      }
      DocGenStandaloneSetup _docGenStandaloneSetup = new DocGenStandaloneSetup();
      Injector injector = _docGenStandaloneSetup.createInjectorAndDoEMFRegistration();
      XtextResourceSet resourceSet = injector.<XtextResourceSet>getInstance(XtextResourceSet.class);
      resourceSet.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);
      URI _createFileURI = URI.createFileURI(this.selectedModelFullPath);
      Resource res = resourceSet.getResource(_createFileURI, true);
      FileInputStream _fileInputStream = new FileInputStream(this.selectedModelFullPath);
      Map<Object,Object> _loadOptions = resourceSet.getLoadOptions();
      resource.load(_fileInputStream, _loadOptions);
      InputOutput.<String>println("\n\nmodel registered\n\n");
      EList<EObject> _contents = res.getContents();
      EObject eobj = _contents.get(0);
      try {
        Model _cast = Model.class.cast(eobj);
        this.modelToCompile = _cast;
      } catch (final Throwable _t) {
        if (_t instanceof ClassCastException) {
          final ClassCastException e = (ClassCastException)_t;
          InputOutput.<String>println("ClassCastException");
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      EList<element> _xmldoc = this.modelToCompile.getXmldoc();
      element _get = _xmldoc.get(0);
      Document _loadMetamodelFileFromPersistenceModelXMLnameSpaceAttribute = this.loadMetamodelFileFromPersistenceModelXMLnameSpaceAttribute(_get);
      DocGenGenerator.metamodelDoc = _loadMetamodelFileFromPersistenceModelXMLnameSpaceAttribute;
      boolean _equals = Objects.equal(DocGenGenerator.metamodelDoc, null);
      if (_equals) {
        Shell _shell_2 = new Shell();
        MessageDialog.openError(_shell_2, "DocGen Error", "No metamodel loaded for the selected persistence model.");
        return;
      }
      NodeList _elementsByTagName = DocGenGenerator.metamodelDoc.getElementsByTagName("eClassifiers");
      this.EClassList = _elementsByTagName;
      this.buildPersistenceModelHashTable();
      String _extension = FilenameUtils.getExtension(this.selectedModelFullPath);
      DocGenLauncher _docGenLauncher = new DocGenLauncher(_extension, this.persistenceModelHashTable);
      this.launcherUI = _docGenLauncher;
      this.launcherUI.setMetamodelDoc(DocGenGenerator.metamodelDoc);
      this.launcherUI.setModelElements(this.modelElements);
      this.launcherUI.open();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Check if the selected file in the project outline is a persistence model.
   * 
   * @return True if the selected file's extension correspond to a valid model extension: drd,ai,rid.
   * Return false otherwise.
   */
  private boolean isValidModelFile() {
    IWorkbench _workbench = PlatformUI.getWorkbench();
    IWorkbenchWindow window = _workbench.getActiveWorkbenchWindow();
    ISelectionService service = window.getSelectionService();
    ISelection _selection = service.getSelection();
    IStructuredSelection selection = IStructuredSelection.class.cast(_selection);
    if ((selection instanceof IStructuredSelection)) {
      IStructuredSelection structuredSelection = IStructuredSelection.class.cast(selection);
      Object firstElement = structuredSelection.getFirstElement();
      if ((firstElement instanceof IFile)) {
        IFile file = IFile.class.cast(firstElement);
        IWorkspace _workspace = ResourcesPlugin.getWorkspace();
        IWorkspaceRoot root = _workspace.getRoot();
        IPath _location = root.getLocation();
        File _file = _location.toFile();
        String _string = _file.toString();
        IPath _fullPath = file.getFullPath();
        String _string_1 = _fullPath.toString();
        String _plus = (_string + _string_1);
        this.selectedModelFullPath = _plus;
        String _name = file.getName();
        String fileExtension = FilenameUtils.getExtension(_name);
        String _lowerCase = fileExtension.toLowerCase();
        boolean _isPersistentModelExtension = PassiPersistentModelExtensions.isPersistentModelExtension(_lowerCase);
        if (_isPersistentModelExtension) {
          return true;
        }
      }
    }
    return false;
  }
  
  /**
   * Extract from the model all the necessary informations to build
   * the documentation.
   * <br></br>
   * This method reads the xml namespace, into the model file to compile, and
   * load the related metamodel file where to find the necessary informations to
   * build the documentation.
   */
  public Document loadMetamodelFileFromPersistenceModelXMLnameSpaceAttribute(final element e) {
    try {
      startTag _start = e.getStart();
      boolean _equals = Objects.equal(_start, null);
      if (_equals) {
        throw new Exception("metamodel namespace information not found. May your diagram has only one element?");
      }
      startTag _start_1 = e.getStart();
      EList<Attribute> _attributes = _start_1.getAttributes();
      boolean _isEmpty = _attributes.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        startTag _start_2 = e.getStart();
        EList<Attribute> _attributes_1 = _start_2.getAttributes();
        for (final Attribute att : _attributes_1) {
          boolean _and = false;
          String _name = att.getName();
          boolean _equals_1 = _name.equals("xmlns");
          if (!_equals_1) {
            _and = false;
          } else {
            String _rightName = att.getRightName();
            boolean _equals_2 = _rightName.equals("xmi");
            boolean _not_1 = (!_equals_2);
            _and = _not_1;
          }
          if (_and) {
            String _val = att.getVal();
            String _metamodelAbsolutePath = this.getMetamodelAbsolutePath(_val);
            this.metamodelFileName = _metamodelAbsolutePath;
            boolean _equals_3 = Objects.equal(this.metamodelFileName, null);
            if (_equals_3) {
              Shell _shell = new Shell();
              MessageDialog.openError(_shell, "DocGen Error", "No metamodel loaded for the selected persistence model.");
              throw new Exception("[DOCGEN ERROR] No metamodel loaded for the selected persistence model.");
            }
            DocumentBuilderFactory docBuildFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = docBuildFactory.newDocumentBuilder();
            File _file = new File(this.metamodelFileName);
            Document metamodelDoc = docBuilder.parse(_file);
            Element _documentElement = metamodelDoc.getDocumentElement();
            _documentElement.normalize();
            EList<element> _innerElement = e.getInnerElement();
            this.modelElements = _innerElement;
            return metamodelDoc;
          }
        }
      } else {
        throw new Exception("[DOCGEN ERROR] xmi:XMI tag not found in the persistence model file. Aborting.");
      }
      return null;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Build the hash table for the persistence model. Every entry
   * in the hash table is in the form:
   * <br></br>
   * [EClass:EStructuralFeature:RowIndex , attributeValue]
   */
  public void buildPersistenceModelHashTable() {
    this.persistenceModelHashTable.clear();
    int numElements = ((Object[])Conversions.unwrapArray(this.modelElements, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, numElements, true);
    for (final Integer i : _doubleDotLessThan) {
      element _get = this.modelElements.get((i).intValue());
      this.insertPersistentModelElementInHashTable(_get, (i).intValue());
    }
  }
  
  /**
   * Read the informations of the element [e] from the persistent model (EClass name and attributes),
   * and insert these informations into the hash table data structure. Every entry in the hash
   * table is in the form:
   * <br></br>
   * {@code
   * [EClass:EStructuralFeature:RowIndex , attributeValue]
   * }
   * 
   * @param currentRow The row where element <i>e</i> is located in the persistence model. Please note
   * that the row count starts from the first element in the metamodel (the xml prolog is not cosidered).
   * @param e The grammar element representing a persistence model element.
   */
  private void insertPersistentModelElementInHashTable(final element e, final int currentRow) {
    if ((e instanceof emptyElement)) {
      emptyElement persistenceModelElement = emptyElement.class.cast(e);
      TagName _tagName = persistenceModelElement.getTagName();
      final String EClassName = _tagName.getRightName();
      persistenceModelElement.getAttributes();
      final Element eClassifier = DocGenGenerator.getEClassByName(EClassName);
      NodeList eStructuralFeatureList = eClassifier.getElementsByTagName("eStructuralFeatures");
      ArrayList<Node> nodeList = new ArrayList<Node>();
      int _length = eStructuralFeatureList.getLength();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
      for (final Integer k : _doubleDotLessThan) {
        Node _item = eStructuralFeatureList.item((k).intValue());
        nodeList.add(_item);
      }
      List<Node> _parentEClassFeatures = DocGenGenerator.getParentEClassFeatures(eClassifier);
      nodeList.addAll(_parentEClassFeatures);
      int _size = nodeList.size();
      ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan_1) {
        {
          Node _get = nodeList.get((i).intValue());
          Element esf = Element.class.cast(_get);
          EList<Attribute> _attributes = persistenceModelElement.getAttributes();
          for (final Attribute attr : _attributes) {
            String _attribute = esf.getAttribute("name");
            String _name = attr.getName();
            boolean _equals = _attribute.equals(_name);
            if (_equals) {
              String _attribute_1 = esf.getAttribute("xsi:type");
              String type = _attribute_1.substring(6);
              String attributeValue = attr.getVal();
              boolean _equals_1 = type.equals("EReference");
              if (_equals_1) {
                StringConcatenation str = new StringConcatenation();
                boolean _equals_2 = EClassName.equals("Agent");
                if (_equals_2) {
                  int a = 1;
                  a = 2;
                }
                InputOutput.<String>print("attr.^val: ");
                String _val = attr.getVal();
                InputOutput.<String>println(_val);
                String _val_1 = attr.getVal();
                final List<String> attributeValues = this.processEReferencePointerAttribute(_val_1);
                int _size_1 = attributeValues.size();
                boolean _greaterThan = (_size_1 > 0);
                if (_greaterThan) {
                  int _size_2 = attributeValues.size();
                  int _minus = (_size_2 - 1);
                  ExclusiveRange _doubleDotLessThan_2 = new ExclusiveRange(0, _minus, true);
                  for (final Integer t : _doubleDotLessThan_2) {
                    {
                      String _get_1 = attributeValues.get((t).intValue());
                      str.append(_get_1);
                      str.append(", ");
                    }
                  }
                  int _size_3 = attributeValues.size();
                  int _minus_1 = (_size_3 - 1);
                  String _get_1 = attributeValues.get(_minus_1);
                  str.append(_get_1);
                  String _string = str.toString();
                  attributeValue = _string;
                }
              }
              String _name_1 = attr.getName();
              String _plus = ((EClassName + ":") + _name_1);
              String _plus_1 = (_plus + ":");
              String _string_1 = Integer.valueOf(currentRow).toString();
              String _plus_2 = (_plus_1 + _string_1);
              String _string_2 = new String(_plus_2);
              this.persistenceModelHashTable.put(_string_2, attributeValue);
            }
          }
        }
      }
    }
  }
  
  /**
   * Check if an attribute (more precisely,an EStructuralFeature element in the metamodel)
   * if an EReference attribute.
   */
  private boolean isEReferenceAttribute(final String EClassName, final String AttributeName) {
    final Element eClassifier = DocGenGenerator.getEClassByName(EClassName);
    NodeList eStructuralFeatureList = eClassifier.getElementsByTagName("eStructuralFeatures");
    ArrayList<Node> nodeList = new ArrayList<Node>();
    int _length = eStructuralFeatureList.getLength();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer k : _doubleDotLessThan) {
      Node _item = eStructuralFeatureList.item((k).intValue());
      nodeList.add(_item);
    }
    List<Node> _parentEClassFeatures = DocGenGenerator.getParentEClassFeatures(eClassifier);
    nodeList.addAll(_parentEClassFeatures);
    int _size = nodeList.size();
    ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan_1) {
      {
        Node _get = nodeList.get((i).intValue());
        Element esf = Element.class.cast(_get);
        String _attribute = esf.getAttribute("name");
        boolean _equals = _attribute.equals(AttributeName);
        if (_equals) {
          String _attribute_1 = esf.getAttribute("xsi:type");
          String type = _attribute_1.substring(6);
          boolean _equals_1 = type.equals("EReference");
          if (_equals_1) {
            return true;
          }
        }
      }
    }
    return false;
  }
  
  /**
   * Return a list containing all the features (EStructuralFeature) of an EClass and
   * of all its parent EClasses.
   */
  public static List<Node> getParentEClassFeatures(final Element eclassifier) {
    ArrayList<Node> nodeList = new ArrayList<Node>();
    String superTypeString = eclassifier.getAttribute("eSuperTypes");
    boolean _isEmpty = superTypeString.isEmpty();
    if (_isEmpty) {
      return nodeList;
    }
    LinkedList<String> superTypesList = DocumentationBuilder.parseSuperTypesString(superTypeString);
    for (final String superType : superTypesList) {
      {
        Element eClassifier = DocGenGenerator.getEClassByName(superType);
        boolean _notEquals = (!Objects.equal(eClassifier, null));
        if (_notEquals) {
          NodeList eStructuralFeatureList = eClassifier.getElementsByTagName("eStructuralFeatures");
          int _length = eStructuralFeatureList.getLength();
          ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
          for (final Integer k : _doubleDotLessThan) {
            Node _item = eStructuralFeatureList.item((k).intValue());
            nodeList.add(_item);
          }
          Element _eClassByName = DocGenGenerator.getEClassByName(superType);
          List<Node> _parentEClassFeatures = DocGenGenerator.getParentEClassFeatures(_eClassByName);
          nodeList.addAll(_parentEClassFeatures);
        }
      }
    }
    return nodeList;
  }
  
  /**
   * Given an attribute of EReference type, process the string of pointers
   * (that is, the value of the attribute) and return a list containing
   * the names of the referenced tag in the model document,
   * in the same order as in the pointer list.
   */
  public List<String> processEReferencePointerAttribute(final String attributeVal) {
    ArrayList<String> listString = new ArrayList<String>();
    LinkedList<Integer> ids = this.getIdList(attributeVal);
    for (final Integer i : ids) {
      {
        element _get = this.modelElements.get((i).intValue());
        emptyElement EClass = emptyElement.class.cast(_get);
        TagName _tagName = EClass.getTagName();
        final String EClassName = _tagName.getRightName();
        EList<Attribute> _attributes = EClass.getAttributes();
        for (final Attribute attr : _attributes) {
          String _name = attr.getName();
          boolean _isKeyAttribute = MetamodelKeyAttributes.isKeyAttribute(_name);
          if (_isKeyAttribute) {
            InputOutput.<String>print("Eclass: ");
            InputOutput.<String>println(EClassName);
            InputOutput.<String>print("Attribute: ");
            String _name_1 = attr.getName();
            InputOutput.<String>println(_name_1);
            String _name_2 = attr.getName();
            boolean _isEReferenceAttribute = this.isEReferenceAttribute(EClassName, _name_2);
            if (_isEReferenceAttribute) {
              InputOutput.<String>println("EReference attribute!");
              String _val = attr.getVal();
              List<String> _processEReferencePointerAttribute = this.processEReferencePointerAttribute(_val);
              listString.addAll(_processEReferencePointerAttribute);
            } else {
              String _val_1 = attr.getVal();
              boolean _isEmpty = _val_1.isEmpty();
              boolean _not = (!_isEmpty);
              if (_not) {
                String _val_2 = attr.getVal();
                listString.add(_val_2);
              }
            }
          }
        }
      }
    }
    return listString;
  }
  
  /**
   * Given the namespace of the model, try to get the referencing metamodel
   * absolute path.
   * 
   * @param nsName the namespace of the persistence model which documentation must be generated. This information
   * is found in the persistence model prolog. For example:
   * <br></br>
   * 
   * {@code
   * <xmi:XMI ... xmlns:drd="http://drd/1.0">
   * }
   */
  public String getMetamodelAbsolutePath(final String nsName) {
    try {
      this.ModelNameSpace = nsName;
      IWorkspace _workspace = ResourcesPlugin.getWorkspace();
      IWorkspaceRoot root = _workspace.getRoot();
      String projectName = MetamodelsLoader.ProjectName;
      IProject project = root.getProject(projectName);
      IFolder metamodelsFolder = project.getFolder("Metamodels");
      QualifiedName _qualifiedName = new QualifiedName(MetamodelsLoader.ProjectName, 
        this.ModelNameSpace);
      String metamodelFname = project.getPersistentProperty(_qualifiedName);
      boolean _equals = Objects.equal(metamodelFname, null);
      if (_equals) {
        return null;
      }
      IPath _location = root.getLocation();
      File _file = _location.toFile();
      String _string = _file.toString();
      IPath _fullPath = metamodelsFolder.getFullPath();
      String _string_1 = _fullPath.toString();
      String _plus = (_string + _string_1);
      String _plus_1 = (_plus + 
        File.separator);
      return (_plus_1 + metamodelFname);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Given an element e representing an EClass tag from the metamodel,
   * search for a feature contained in the specified EClass that has the same
   * name as the [name] input attribute.
   * 
   * @return the eStructuralFeatures element that has the specified name. Null if no feature is found.
   */
  public Element getEStructuralFeature(final Element e, final String name) {
    NodeList eStructFeatList = e.getElementsByTagName("eStructuralFeatures");
    int numeStructFeatList = eStructFeatList.getLength();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, numeStructFeatList, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        Node _item = eStructFeatList.item((i).intValue());
        Element node = Element.class.cast(_item);
        String _attribute = node.getAttribute("name");
        boolean _equals = _attribute.equals(name);
        if (_equals) {
          return node;
        }
      }
    }
    return null;
  }
  
  /**
   * Given an element e representing an eClassifier tag from the metamodel,
   * return the type of this element, without the string "ecore:".
   */
  public String getEStructuralFeatureTypeAttribute(final Element e) {
    String _attribute = e.getAttribute("xsi:type");
    return _attribute.substring(6);
  }
  
  /**
   * Given a tag name from the persistence model, that is, "Actor"
   * in the following example:
   * <pre>
   * {@code
   * <passiseq:Actor name="NewActor1" List_RAMessagesOut="/3"/>
   * }
   * </pre>
   * this method searches  the EClass "Actor" in the metamodel, and
   * return the corresponding element if it is found.
   * <br></br>
   * @return the corresponding EClass element in the metamodel. If no EClass is found, return null.
   */
  public static Element getEClassByName(final String tagName) {
    NodeList listEclassifier = DocGenGenerator.metamodelDoc.getElementsByTagName("eClassifiers");
    int length = listEclassifier.getLength();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, length, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        Node _item = listEclassifier.item((i).intValue());
        Element node = Element.class.cast(_item);
        String name = node.getAttribute("name");
        boolean _equals = name.equals(tagName);
        if (_equals) {
          return node;
        }
      }
    }
    return null;
  }
  
  /**
   * Given a string formatted as "/0 /1 /2 ..." this function return a list
   * containing the IDs of the referenced elements by the current parsed tag.
   * <pre>
   * For example, given the following string:
   * </pre>
   * <pre>
   *  s = "/1 /34 /12 /7"
   * </pre>
   * the returned list is [1 34 12 7]
   */
  public LinkedList<Integer> getIdList(final String s) {
    LinkedList<Integer> l = new LinkedList<Integer>();
    Pattern pattern = Pattern.compile("(/([0-9]+))+");
    Matcher matcher = pattern.matcher(s);
    int _groupCount = matcher.groupCount();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _groupCount, true);
    for (final Integer i : _doubleDotLessThan) {
      boolean _find = matcher.find();
      if (_find) {
        String st = matcher.group();
        String _substring = st.substring(1);
        st = _substring;
        int _parseInt = Integer.parseInt(st);
        l.add(Integer.valueOf(_parseInt));
      }
    }
    return l;
  }
}
